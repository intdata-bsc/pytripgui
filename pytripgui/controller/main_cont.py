import os
import pytrip as pt

from pytripgui.viewcanvas_vc.viewcanvas_cont import ViewCanvasCont
from pytripgui.controller.dvh import Dvh
from pytripgui.controller.lvh import Lvh

import logging
logger = logging.getLogger(__name__)


class MainController(object):

    # this is probably not correct solution
    # plotupdate = pyqtSignal()

    def __init__(self, app):
        self.model = app.model  # Q: mark private? _model
        self.app = app  # not sure if this is correct. May controller use App?

        self.plot = ViewCanvasCont(self.model.one_plot, app.view.ui.one_viewcanvas)  # ViewCanvas for CTX, VDX and DOS

        self.dvh = Dvh(self.model, self.app.view)   # DVH plot
        self.lvh = Lvh(self.model, self.app.view)   # DVH plot

        self._connect_ui()     # connect signals to autogenerated UI
        self._open_settings()  # open settings file and update model

        # self.plotupdate.connect(self.plot.update_viewcanvas)

    def _open_settings(self):
        """
        """
        model = self.model

        self.settings = SettingsController(model)

    def _connect_ui(self):
        """
        Connect any signals emited from the autogenerated UI to any methods
        of home-made classes.
        """

        ui = self.app.view.ui
        # QtDesigner does not really allow custom slot names of different classes.
        # I.e. you may specify "open_ctx" as a slot, but not "ctrl.open_ctx".
        # Solution is simply to manually make all the signal list here.

        ui.actionOpen_Dicom.triggered.connect(self.open_dicom_dialog)
        ui.actionOpen_Voxelplan.triggered.connect(self.open_voxelplan_dialog)

        ui.actionDoseCube.triggered.connect(self.import_dos_dialog)
        ui.actionLETCube.triggered.connect(self.import_let_dialog)
        ui.action_exec.triggered.connect(self.import_exec_dialog)

        ui.actionOpen_Project.triggered.connect(self.open_project)
        ui.actionSave_Project.triggered.connect(self.save_project)

        ui.actionExport_Dicom.triggered.connect(self.export_dicom_dialog)
        ui.actionExport_Voxelplan.triggered.connect(self.export_voxelplan_dialog)

        ui.actionExit.triggered.connect(self.on_exit)
        ui.actionNew_Plan.triggered.connect(self.on_new_plan)

        # ui.tab.resized.connect(self.change_foobar) wont work, doesnt exist

    # called from view class
    def change_foobar(self, event):
        # put control logic here
        logger.debug("Change foobar {}".format(event))
        # self.model.foobar = value
        # self.model.announce_update()

    def open_dicom_dialog(self, event):
        """
        Opens a DICOM set and sets it to the model.
        """
        logger.debug("Open DICOM triggered")
        model = self.model

        ddir = os.path.dirname(model.dicom_path)

        # Start a file dialog for selecting input files
        from pytripgui.view.dialogs import MyDialogs
        ddir = MyDialogs.openDirectoryDialog(self.app,
                                             "Open Directory with DICOM Files",
                                             ddir)
        if not ddir:
            return
        self.open_dicom(ddir)
        model.dicom_path = ddir
        self.settings.save()

    def open_dicom(self, ddir):
        """
        Open a DICOM directory. Images must be present. RTSS is optional.
        """
        model = self.model    # local object of plot_model
        pm = self.model.plot  # local object of plot_model

        logger.debug("open dicom '{}'".format(ddir))
        dcm = pt.dicomhelper.read_dicom_dir(ddir)

        ctx = None
        vdx = None

        if 'images' in dcm:
            logger.debug("Found images in DICOM")
            ctx = pt.CtxCube()
            ctx.read_dicom(dcm)

            model.ctx = ctx
            pm.ctx = ctx
        else:
            from pytripgui.view.dialogs import MyDialogs
            MyDialogs.show_error("No images found in selected DICOM directory.")
            return

        if 'rtss' in dcm:
            logger.debug("Found rtss in DICOM")
            vdx = pt.VdxCube(cube=ctx)
            vdx.read_dicom(dcm)
            for voi in vdx.vois:
                pm.vois.append(voi)

            # This is a workaround for pytrip issue #455 https://github.com/pytrip/pytrip/issues/455
            vdx.basename = "basename"

            model.vdx = vdx
            pm.vdx = vdx

        # TODO: RTplan data

        # add cube to the treeviews
        self.tree.update_tree()

        # update the canvas
        self.plot.update_viewcanvas()



    def on_new_plan(self, event):
        """
        New plan opened from window->plan->New Plan
        """
        logger.debug("add_new_plan() {}".format(None))

        from pytrip.tripexecuter import Plan
        from pytripgui.plan_vc import PlanQtView
        from pytripgui.plan_vc import PlanController

        # selected_plan = self._node_obj
        plan = Plan()
        plan.basename = self.model.ctx.basename
        view = PlanQtView()
        global_kernels = self.model.kernels
        default_kernel = self.model.kernels[0]  # TODO select default kernel
        plan.kernel = default_kernel

        controller = PlanController(plan, view, global_kernels, self.model.vdx.vois)
        controller.set_view_from_model()
        view.show()

        if controller.user_clicked_save:
            self.model.plans.append(plan)
            self.tree.update_tree()

    def on_kernel(self, event):
        """
        Kernel dialog opened from window->settings->kernel
        """
        from pytripgui.kernel_vc import KernelQtView
        from pytripgui.kernel_vc import KernelController

        model = self.model.kernels
        view = KernelQtView()
        controller = KernelController(model, view)
        controller.set_view_from_model()
        view.show()

        if controller.user_clicked_save:
            self.settings.save()

    @staticmethod
    def on_exit(event):
        logger.debug("on_exit() triggered")
        import sys
        sys.exit()
